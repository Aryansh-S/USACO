#include <iostream>
#include <cstdio>
#include <deque>
#include <utility>
using namespace std;

#define maxn 100000
#define maxm 100000
typedef pair<int,int> pii;
#define f first
#define s second
int n,m,ans,choice[maxn]; deque<int> cereal[maxm]; pair<int,int> cowvals[maxn];
bool firstcheck[maxm]; //look at cow i

#define problemname "cereal"

int main(){
  ios_base::sync_with_stdio(0); cin.tie(0);
  freopen(problemname ".in", "r", stdin); freopen(problemname ".out", "w", stdout);
  cin >> n >> m;
  for(int i=0; i<n; i++){
    int a,b; cin >> a >> b; a--,b--;
    cowvals[i].f=a; cowvals[i].s=b;
    cereal[a].push_back(i); cereal[b].push_back(i);
    if(!firstcheck[a]){
      firstcheck[a]=1;
      choice[i]=1; ans++;
    }
    else if(!firstcheck[b]){
      firstcheck[b]=1;
      choice[i]=2; ans++;
    }
    else choice[i]=3;
  } cout << ans << "\n";
  for(int i=0; i<n; i++){
    ans--; //resolution is first choice
    int firstchoice=cowvals[i].f;
    while(1){ //resolve dequeue is first cereal queue
		#define first_cereal_q cereal[firstchoice]
		if(!first_cereal_q.empty()){ /*TRY*/ //nxt is to_resolve
			#define nxt first_cereal_q.front()
			first_cereal_q.pop_front(); //level of resolution(to resolve, resolution)
			while(nxt<=i || choice[nxt]<=(cowvals[nxt].f==firstchoice)?1:(cowvals[nxt].s==firstchoice)?2:3){
				nxt=first_cereal_q.front(); first_cereal_q.pop_front();

			}

		}
		else{break;}
		if(cowvals[nxt]==3){
			ans+=1;
			//states[to_resolve] = level_of_resolution(to_resolve, resolution)
			cowvals[nxt]=(cowvals[nxt].f==firstchoice)?1:(cowvals[nxt].s==firstchoice)?2:3;
			break;
		}
		else{
			firstchoice=cowvals[nxt].s;
		}
		cowvals[nxt]=(cowvals[nxt].f==firstchoice)?1:(cowvals[nxt].s==firstchoice)?2:3;
    }
    cout << ans << "\n";
  }
  return 0; //if not at the front, doesn't get cereal
}
